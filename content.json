{"pages":[{"title":"关于我","text":"","link":"/%E5%85%B3%E4%BA%8E%E6%88%91/index.html"},{"title":"示例页面","text":"这是示范页面。页面和博客文章不同，它的位置是固定的，通常会在站点导航栏显示。很多用户都创建一个“关于”页面，向访客介绍自己。例如： 欢迎！我白天是个邮递员，晚上就是个有抱负的演员。这是我的博客。我住在天朝的帝都，有条叫做 Jack 的狗。 … 或这个： XYZ Doohickey 公司成立于 1971 年，自从建立以来，我们一直向社会贡献着优秀 doohickies。我们的公司总部位于天朝魔都，有着超过两千名员工，对魔都政府税收有着巨大贡献。 而您，作为一个 WordPress 用户，我们建议您访问控制板，删除本页面，然后添加您自己的页面。祝您使用愉快！","link":"/sample-page/index.html"}],"posts":[{"title":"Laravel 笔记 持续更新","text":"安装 1composer create-project --prefer-dist laravel/laravel blog 5.5.* 路由 基本形式 ： 12345678910111213141516Route::get('/','控制器@方法');Route::get('/post','\\App\\Http\\Controllers\\PostController@index');/*对应html代码&lt;form action = &quot;/post&quot; methot = &quot;GET&quot;&gt;&lt;/form&gt;*/Route::put('/post','\\App\\Http\\Controllers\\PostController@index');/*对应html代码&lt;form action = &quot;/post&quot; methot = &quot;POST&quot;&gt; {{method_filed(&quot;PUT)}}&lt;/form&gt;*/Route::any('/post','\\App\\Http\\Controllers\\PostController@index');//支持所有提交方法Route::match(('POST','GET'),'/post','\\App\\Http\\Controllers\\PostController@index');//支持POST和GET方法 12Route::get('/posts',['as'=&gt;'posts','uses'=&gt;'PostController@index']);// posts路由，as是给这个路由重命名为posts，这样就可以通过route('posts',parameter)来访问这个路由,parameter是路由中的参数，可以是数组，uses对应的是默认控制器方法 路由参数： 1234Route::get('/post{id}','\\App\\Http\\Controllers\\PostController@index');//传进来参数id function index($id){ //从对应的控制器的方法里接收 }; 路由分组： 12345Route::group(['prefix'=&gt;'post'],function(){ Route::get('/','\\App\\Http\\Controllers\\PostController@index');//对应'/post' Route::post('/','\\App\\Http\\Controllers\\PostController@index');//同上 Route::post('/creat','\\App\\Http\\Controllers\\PostController@index');//对应'/post/create'}) url() url 辅助函数可用于为应用生成任意 URL，并且生成的 URL 会自动使用当前请求的 scheme（HTTP or HTTPS） 和 host 属性 asset asset()方法用于引入 CSS/JavaScript/images 等文件,文件必须存放在public文件目录下。 渲染 基本与CI相似 12345public function index($value='') { return view(&quot;post/index&quot;,$data);//渲染view/post/index.blade.php文件,$data为数组 //或者 return view(&quot;post/index&quot;)-&gt;with(['post'=&gt;$post]); } blade模板 if语句 1234567@if ($bool == false) &lt;h2 class=&quot;blog-post-title&quot;&gt;{{$bool}}&lt;/h2&gt;@elseif ···@else ···@endif 循环 123@for ($i=0;$i&lt;10;$i++) &lt;h2 class=&quot;blog-post-title&quot;&gt;{{$bool}}&lt;/h2&gt;@endfor 1234@foreach ($users as $k =&gt; $v) &lt;p&gt;此用户为 {{$k.'--'.$v}}&lt;/p&gt;//$loop-&gt;iteration 从1开始循环计数 $loop-&gt;index 从0开始计数@endforeach 123@while (true) &lt;p&gt;我永远都在跑循环。&lt;/p&gt;@endwhile 引用与调用 将相同的部分全部写出来，将不同的部分用@yield('content')代替，然后放在view/layout/main.blade.php下，引用的时候： 1234@extends('layout.main')@section('content') // code....@endsection 渲染为html {!! $content !!} migration 作用：记录对数据库的操作，实现对数据库的迁移 在命令行输入php artisan make:migration create_posts_table +(名字，一般命名为creat_表名_table) 用migration建表：在migration的up（创建函数）里写 1234567Schema::create('posts', function (Blueprint $table) { $table-&gt;increments('id');//自增id $table-&gt;string('title',100)-&gt;default('');//vachar类型的标题，最大长度100 $table-&gt;text('content');//text类型的content $table-&gt;integer('user_id')-&gt;default(0); $table-&gt;timestamps();//自动创建create_at update_at字段 });// 如果想更新，把create换成table 设置字段的默认长度在\\App\\Providers\\AppServiceProvider.php的boot里面设置 1234use Illuminate\\Support\\Facades\\Schema;···//默认mb4string 类型长度 Schema::defaultStringLength(191); 然后运行 php artisan migrate就会自动建表了 回滚 1Schema::dropIfExists('posts'); ##文章模型 模型使用ORM来创建模型，使用class来表示一个表，每一个表都有一个类来来提供给上层使用，可以通过对模型的查询，增加，删除操作，来对数据表操作，这样就将数据表抽象化 创建模型 在命令行输入以下代码：php artisan make:model Post默认对应表posts 12345class Post extends Model{ //默认对应的表=&gt;posts//指定表名 protected $table = &quot;posts2&quot;;} 默认行为 Eloquent 默认每张表的主键名为id，你可以在模型类中定义一个$primaryKey属性来覆盖该约定。 此外，Eloquent默认主键字段是自增的整型数据，这意味着主键将会被自动转化为int类型，如果你想要使用非自增或非数字类型主键，必须在对应模型中设置$incrementing属性为false。 默认情况下，Eloquent 期望created_at和updated_at已经存在于数据表中，如果你不想要这些 Laravel 自动管理的列，在模型类中设置$timestamps属性为false 在控制器使用模型 $post = \\App\\Post;由于模型经常使用，可以在控制器上方加use \\App\\Post;在方法里面可以直接写。返回的是collection对象 1$post = Post::orderBy('create_at','desc')-&gt;get();//获取posts表单额所有数据，并按照时间降序排列 模型关联 belongsTo 1234567class Post extends Model{ public function user() { return $this-&gt;belongsTo('App\\user','user_id','id'); }} 此方法会从关联模型(App\\user)中，查询此模型(Post)的外键(user_id)为关联模型的主键(id)的数据 使用： Post::find($id)-&gt;get()[0]-&gt;name用来获取id为$id的文章的user的姓名 hasMany 123456class Member extends Model{ public function blogs(){ return $this-&gt;hasMany('App\\Blog',&quot;member_id&quot;,&quot;id&quot;); }} 此方法会从关联模型(App\\Blog)中，查找关联模型的外键(member_id)为此模型(Member)的主键(id)的数据 belongsTomany 1234567class Member extends Model{ public function projects() { return $this-&gt;belongsToMany('App\\Project','member_project','member_id','project_id'); }} 此方法会从关联模型(App\\Project)cha数据,条件为：先在表(member_project)找到此模型(member)主键为(member_id)数据,找到对应的project_id，然后在project表中找主键为project的数据 数据填充 在database/factories里写 123456$factory-&gt;define(App\\Post::class, function (Faker\\Generator $faker) { return [ 'title' =&gt; $faker-&gt;sentence(6),//6个单词 'content' =&gt; $faker-&gt;paragraph(10),//10句话 ];}); 然后再命令框运行 php artisan tinker -&gt;factory(App\\Post::class,20)-&gt;create(); 简单分页 控制器里写 12$post = Post::orderBy('create_at','desc')-&gt;paginate(10);//每页显示的条数return view(&quot;post/index&quot;,array('posts'=&gt;$posts,)); blade里写 1{{$post-&gt;links()}} 字符截断 blade页面写 1{{str_limit($post-&gt;content,100,'...')}}//显示100字符，超出部分显示... 文章的增删改查 文章详情页 路由时用的是模型绑定: 1Route::get('/posts/{post}','\\App\\Http\\Controllers\\PostController@show')-&gt;where(['post' =&gt; '[0-9]+']);//绑定post模型 控制器里面写 12345public function show(Post $post) { $data['post'] = $post; return view('post/show',$data); } 创建文章 post提交时，必须使用一个函数{{csrf_field()}} 接收参数request()-&gt;all();或者request(['title','content']);特定字段名 使用post的crate方法时，需要在post模型里面添加两个属性 12protected $guarded = [];//不可以注入的字段protected $fillable = ['title','content'];//可以注入的数据字段 利用模型存数据库 Post::create([数组]);//此方法会同时插入created_at 和 upadated_at字段 表单验证 123456$this-&gt;validate(request(), [ 'title' =&gt; 'required|string|max:100|min:5', //title的验证规则:必填，字符串，长度大于5小于100 'content' =&gt; 'required|string|min:10',],[ 'title.min' =&gt;'文章标题过短',//自定义错误提示]); 返回错误时会可以在前端blade模板中直接写 1234567@if(count($errors)&gt;0) &lt;div class=&quot;alert-danger alert&quot;&gt; @foreach($errors-&gt;all() as $error) &lt;li&gt;{{$error}}&lt;/li&gt; @endforeach &lt;/div&gt;@endif 如果验证失败后想进行什么操作 123456789101112131415161718use Validator;···$validator = Validator::make($request-&gt;all(),[ 'title' =&gt; 'required|string|max:100|min:5', //title的验证规则:必填，字符串，长度大于5小于100 'content' =&gt; 'required|string|min:10',],[ 'title.min' =&gt;'文章标题过短',//自定义错误提示]);//如果验证失败if ($validator-&gt;fails()) { $request-&gt;session()-&gt;flash('tab', '2'); //闪存信息到session return redirect() -&gt;back() -&gt;withErrors($validator);} *如果显示错误想变成中文，可以resource/lang/下新建一个文件夹/zh，将en下的文件复制到这里面，然后参考linkdesu写的复制下来，覆盖到validation。然后在config/app.php里面将locale改为zh laravel的表单验证自带重复确认验证confirmed： 具体用法为：验证字段必须有一个匹配字段foo_confirmation，例如，如果验证字段是password，必须输入一个与之匹配的password_confirmation字段 unique:table,column,except,idColumn 此验证规则会在table表（除去idColumn/主键为except的项）中检查column字段中有没有与之重复的值。 1'email' =&gt; 'unique:users,email_address,'.$user-&gt;id.',user_id', 修改文章 1234567public function update(Post $post) { $post-&gt;title = request('title'); $post-&gt;content = request('content'); $post-&gt;save(); return redirect(&quot;posts/$post-&gt;id&quot;); } 删除文章 12345public function delete(Post $post) { post-&gt;delete(); return view(''); } Auth门脸类 配置流程 将所要应用Auth的模型（比如User这个model）继承 Authenticate 具体在config/auth里面修改 方法 登录 1234if(Auth::attempt(['email'=&gt;$email,'password'=&gt;$password],$remember)) { //此数组会和对应模型的数据库进行匹配,匹配正确会进入到此分支语句中 } 登出 1Auth::logout(); 获取当前已通过认证的用户 1$user = Auth::user() 获取当前已认证用户的id 1$id = Auth::id(); Policy策略类(用于权限验证) 创建 1php artisan make:policy Postpolicy 引入模型，添加方法 123456789use App\\Post； //文章use App\\User; //用户//修改权限//判断用户的id和文章的id是否相等，相等返回true，不相等返回falsepublic function update(User $user,Post $post){ return $user-&gt;id == $post-&gt;user_id;} 将策略类和模型关联起来 在app/Policies/AuthServiceProvideer.php里 1234protected $policies = [ //'App\\Model' =&gt; 'App\\Policies\\ModelPolicy', 'App\\Post' =&gt; 'App\\Policies\\PostPolicy', ]; 策略判断 在要进行权限验证的控制器的方法里写 1$this-&gt;authorize('update',$post); 此时会获取登录的用户Auth::user()来判断是否有权限，如果通过权限验证会继续，不通过会返回错误页面 也可以这样： 123if($user-&gt;can('update',$post)){ ***************} 如果有权限更新，会继续进行，否则，会报错 在要进行权限验证的blade模板里面写 123@can('update',$post) *****************@endcan 此时会获取登录的用户Auth::user()来判断是否有权限 其他 修改时区 ： 在\\App\\config\\app.php 里修改 timezone =&gt;'Aisa/Shanghai' 修改时间格式： $post-&gt;created_at-&gt;toFormattedDateString()","link":"/2018/06/24/laravel-%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"title":"Linux操作系统下，重装mysql数据库（升级MYSQL版本）","text":"重装的时候，先把/data/文件夹下的mysql文件夹tar压缩备份一遍，卸载掉之后，安装完新的数据库 如果mysql数据库服务正在运行，则先让它停止，然后把备份的mysql复制覆盖新的mysql文件夹，然后改拥有者用户为_mysql_ ，这样就能保留原数据了","link":"/2018/02/08/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8B%EF%BC%8C%E9%87%8D%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%8D%87%E7%BA%A7mysql%E7%89%88%E6%9C%AC%EF%BC%89/"},{"title":"centos操作系统apache服务器添加虚拟站点","text":"修改apache/conf下的httpd.config文件 在220行左右，修改Directory标签，此为修改权限。 1234&lt;Directory/&gt; AllowOverride All Require all denied&lt;/Directory&gt; 如图所示： 在498行左右，修改Virtual hosts，去掉下面那句话的注释 12# Virtual hostsInclude conf/extra/httpd-vhosts.conf 如图所示： 修改apache/conf/extra下的httpd-vhosts文件 如果以前可以访问的前缀是 www ，在文件末尾先加上以下代码 12345678910&lt;VirtualHost *:80&gt; ServerName www.huhuapin.cn DocumentRoot &quot;/data/wwwroot/wordpress&quot; &lt;Directory /&gt; Options FollowSymLinks AllowOverride All Order allow,deny Allow from all &lt;/Directory&gt; &lt;/VirtualHost&gt; 如图所示 然后在其下面添加你所想配置的虚拟站点 12345678910111213141516&lt;VirtualHost *:80&gt; ServerAdmin admin@example.com DocumentRoot &quot;/data/wwwroot/test.huhuapin.cn&quot; ServerName test.huhuapin.cn ErrorLog &quot;/data/wwwlogs/test.huhuapin.cn_error_apache.log&quot; CustomLog &quot;/data/wwwlogs/test.huhuapin.cn_apache.log&quot; common&lt;Directory &quot;/data/wwwroot/test.huhuapin.cn&quot;&gt; SetOutputFilter DEFLATE Options FollowSymLinks ExecCGI Require all granted AllowOverride All Order allow,deny Allow from all DirectoryIndex index.html index.php&lt;/Directory&gt;&lt;/VirtualHost&gt; 如图所示： 重启apache，然后就大功告成了","link":"/2018/03/07/centos%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fapache%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B7%BB%E5%8A%A0%E8%99%9A%E6%8B%9F%E7%AB%99%E7%82%B9/"},{"title":"laravel上传的图片无法打开，报错Unable to guess the mime type as no guessers are available","text":"在做web大作业时，将laravel项目从本地迁移到服务器上，出现了错误。上传的图片无法加载出来。 打开图片链接，发现报错如下 经百度发现是未开启php的file_info这个扩展组件 博主是用oneinstack配的环境， 解决办法如下： 进入oneinstack解压目录，运行./addons.sh命令，添加组件 选择4 Install/Uninstall fileinfo PHP Extension 过一会，就安装成功了，重启apache/Nginx就可以正常显示了 如果安装失败，或者是环境不适用oneinstack配的，可以参考以下链接Unable to guess the mime type as no guessers are available","link":"/2018/05/16/laravel%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%EF%BC%8C%E6%8A%A5%E9%94%99unable-to-guess-the-mime-type-as-no-guessers-are-available/"},{"title":"laravel判断数据库中是否有该值","text":"自己在学习过程中的一点问题 记下来 123456789101112131415$users = DB::table('users')-&gt;where('id',$id)-&gt;get();if($users){//有数据}else{//没数据}或if(is_null($users)){//}或if(empty($users)){//} 以上方法都是不行的，在使用Laravel Eloquent模型时，我们要判断取出的结果集是否为空，但我们发现直接使用is_null或empty是无法判段它结果集是否为空的。 var_dump之后我们很容易发现，即使取到的空结果集， Eloquent仍然会返回object(Illuminate\\Support\\Collection)对象实例。其实，Eloquent已经给我们封装几个判断方法如下： 12345678910$users = DB::table('users')-&gt;where('id',$id)-&gt;get();if ($users-&gt;first()) {//若无数据，打印出来为null//}if (!$users-&gt;isEmpty()) {//}if ($users-&gt;count()) {//若无数据，打印出来为0//}","link":"/2017/11/15/laravel%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E8%AF%A5%E5%80%BC/"},{"title":"mysql利用geometry字段在laravel框架下，来完成空间类查询","text":"在做一项目时，用到经纬度坐标，经过多次百度，找到了geometry这个字段，用这个字段，MYSQL提供了很方便的函数，比如查询两个点之间的距离，查询距离这个点多少米的所有点，查询距离这个点最近的几个点，然后用laravel写了几个功能。 参考链接： mysql中geometry类型的简单使用 （主） 查找1附近点–Geohash方案讨论 建表 表test ###表point 其中，gis的类型是geometry类型的，用来储存经纬度，geohash是利用gis经过哈希算法得到的字符串，利用此字符串比较效率更高，具体见文章顶部连接，它的结构如下： 插入数据 此处只说laravel的插入方法，具体sql命令详见文章顶链接 12345test = new Test();test-&gt;longitude = 118.0065880;test-&gt;latitude = 36.8197360;test-&gt;save();DB::statement(&quot;update test set gis = geomfromtext('point(test-&gt;longitude test-&gt;latitude)') where id = $test-&gt;id&quot;); Test是laravel的一个模型，对应test数据表，先把经纬度赋值给test的longitude和latitude字段，然后再插入gis字段，因为`geomfromtext()`是MYSQL提供的方法，所以不能直接`test-&gt;gis = geomfromtext(‘point($test-&gt;longitude $test-&gt;latitude)’);`,而是用DB的statement方法来运行原生SQL命令。 查询两点的距离 point id name gis geohash longitude latitude 1 淄博客运总站 POINT(118.007117 36.793214) wwecm640 118.007117 36.793214 test id gis geohash longitude latitude 12 POINT(117.035999 36.687248) wwe0xnxn 117.035999 36.687248 代码如下 1234567891011distance \\= DB::select('select floor(st\\_distance\\_sphere( (select gis from test where id = ?),gis)) distance from point where id= ?',[12,1]);dd(distance);/*查询结果array:1 [▼ 0 =&gt; {#184 ▼ +&quot;distance&quot;: 87331.0 }]*/ 查询到这个点距离最短的点 12345678910111213141516point\\_gis \\= Test::find(12)\\-&gt;gis;point\\= DB::select('select *,floor(st_distance_sphere(?,gis)) distance from point order by distance asc',[point\\_gis\\])\\[0\\];dd(point);/*查询结果{#185 ▼ +&quot;id&quot;: 1 +&quot;name&quot;: &quot;淄博客运总站&quot; +&quot;gis&quot;: b&quot;\\x00\\x00\\x00\\x00\\x01\\x01\\x00\\x00\\x00©Å▄ÜtÇ]@[]N\\têeB@&quot; +&quot;geohash&quot;: &quot;wwecm640&quot; +&quot;longitude&quot;: 118.007117 +&quot;latitude&quot;: 36.793214 +&quot;distance&quot;: 2946.0}*/ 原理：$point_gis获取到了test表中 id为12的gis字段的值 利用SQL的空间距离查询函数st_distance_sphere(?,?)在point表中查询每个点到 test表中id为12的点的距离，并按距离升序排列。floor()是把计算出的距离取整。","link":"/2018/02/07/mysql%E5%88%A9%E7%94%A8geometry%E5%AD%97%E6%AE%B5%E5%9C%A8laravel%E6%A1%86%E6%9E%B6%E4%B8%8B%EF%BC%8C%E6%9D%A5%E5%AE%8C%E6%88%90%E7%A9%BA%E9%97%B4%E7%B1%BB%E6%9F%A5%E8%AF%A2/"},{"title":"PHP CI笔记","text":"控制器 访问：入口文件.php/控制器/方法 所有的控制器 直接或间接继承CI_Controller类 私有方法或者属性 可以用private声明或者前面加下划线 如：_user 则该方法不能被访问 视图 $this-&gt;load-&gt;view(视图，$data);//默认加载views里的php 文件，不写后缀，第二个参数为php里用到的数据，可选，多个数据应用数组保存 推荐使用 123&lt;? php foreach(\\$list as \\$item):?&gt; &lt;?=\\$item['name']?&gt;&lt;? php endforeach;?&gt; 超级对象 load URI类（已经自动加载） 提供了segment(n,$no_result = NULL)方法，第一个是从入口文件到值名的条数，第二个参数为可选的，默认为 NULL ，它用于设置当所请求的段不存在时的返回值 入口文件.php/控制器/方法/值1/值2 $this-&gt;uri-&gt;segment(3);//值1 $this-&gt;uri-&gt;segment(4);//值2 了解更多访问https://codeigniter.org.cn/user_guide/libraries/uri.html input输入类 $this-&gt;input-&gt;post[‘username’]; //$_POST[‘username’]; $this-&gt;input-&gt;server[‘DOCUMENT_ROOT’]; //$_SERVER[‘DOCUMENT_ROOT’]; 数据库操作 在application/config/database.php来配置数据库 $this-&gt;load-&gt;database(); //装载数据库操作类，装载成功后，放在超级对象的属性中，默认属性名是db 可以在config/autoload/autoload[‘libraries’] = array(‘adtabase’);来设置自动加载自动加载 $res = $this- &gt;db -&gt;query( 查询命令) ;//返回的不是资源句柄，而是一个对象 ​ $res-&gt;result(); //将所有查询到的结果存到一个数组里面，返回一个数组，数组的每个项的值是一个对象（即每条数据对应一个对象） ​ $res-&gt;result_array(); //返回关联数组 相当于 mysqli_fetch_all($res,MYSQLI_ASSOC) ​ $res-&gt;row() //返回第一条数据（对象） ​ $res-&gt;row_array() // 返回第一条数据（数组) $this-&gt;db&gt;query(插入命令/更新命令);//返回布尔值 $this-&gt;db-&gt;affected_rows() //查询受影响的行数 相当于mysqli_affected_rows 插入的时候把接受到的数据存进一个数组里，然后插入的时候传数组名 如：$data[0] = ‘$name’; $data[1] =’$id’; $sql = Insert into asd (name,password) value (?,md5(?));//问号表示参数，当参数大于1时，需要传进去一个索引数组 $this-&gt;db&gt;query($sql,$data);//传一个索引数组 配置交换表前缀 db[default] = 'blog_';** **db[default] = ‘my_’; 那么我们在写sql语句时就用my_这个表前缀，ci会自动把my_换为blog_，所以，dbprefix可以随便修改，方便我们修改数据库名。 如：$sql = “SELECT * FROM my_archive”; Active Record application/config/database.php; $active_record = TRUE; 通过这个启动AR 在配置文件中配置完表前缀后，会自动添加 $this -&gt;db -&gt;get(‘表名’);//对应select 方法 $this -&gt;db -&gt;insert(‘表名’,‘关联数组’);//对应insert方法 前提是键名要与表的字段相对 $this -&gt; db -&gt;insert(‘表名’,‘关联数组’,‘条件’); //对应update $this -&gt; db -&gt;delete(‘表名’,‘条件’);//对应delete 123456$this-&gt;db-&gt;select('id,title') -&gt;from('text') -&gt;where('id &gt;=',3)//where(array('id &gt;'=&gt;3,'title' =&gt; 'ci')) -&gt;limit(3,2)//从第二个数据往后，取三个 相当sql的limt(2,3); -&gt;order_by('id desc') -&gt;get(); 扩展CI控制器 用于登录验证，权限验证 在application/core/My_controller.php 此控制器要继承至CI_Controller parent::controller(); 其他控制器需要继承至此新建的控制器 模型 命名：如user_model.php 里面继承至CI_Model类 通常类名的命名如 User_model $this-&gt;load-&gt;model(‘user_mode’,‘别名’);//加载模型，加载完成后，自动成为超级对象的属性 this-&gt;user-&gt;getAll();//调取模型里的getAll(自己写的)方法，获取数据 URL相关函数 使用时 需要在控制器中加载（可以配置自动加载） 1$this-&gt;load-&gt;helper('url'); site_url(‘控制器/方法’) 动态加载url base_url () //返回网站的根目录（ci目录） 分页类 $this-&gt;load-&gt;library(‘pagination’);//在类库中装载分页类 $page_size = 10;//自定义变量表示 每页显示10条数据 $config[‘total_rows’] = 100;//表示每页有100条数据 $config[‘per_page’] = $page_size; $config[‘base_url’] = site_url(‘user/index’);//设置按钮的链接地址对应方法 使用前需要加载url类 config['first_link'] = '首页';//自定义按钮名 config[‘prev_link’] = ‘上一页’; config['next_link'] = '下一页'; config[‘last_link’] = ‘最后一页’; $this-&gt;pagination-&gt;initialize($config);初始化分页属性 $this-&gt;pagination-&gt;create_links();设置分页按钮 ​ 一般可以$data[‘links’] = $this-&gt;pagination-&gt;create_links(); 然后么在视图里使用 $offset = intval($this-&gt;uri-&gt;segment(3));//获取链接的分页数字并转换成整形，当切换第一页的时候uri里显示的 空 转换成0 $sql = “select * from blog limit $offset,$page_size”; session类 $this-&gt;load-&gt;library(‘pagination’);使用前先装载 使用时 不让session被随意修改 在application/config/config.php里的$config[‘encryption_key’] = ‘’;加密 使用 12345$this-&gt;session-&gt;set_userdata($array); //添加session数据 or $this-&gt;session-&gt;set_userdata('some_name', 'some_value');//添加一个键值对$name = $this-&gt;session-&gt;userdata('name');//获取键名为name的键值 如果想获取所有已存在的 userdata ，你可以忽略参数$this-&gt;session-&gt;has_userdata('some_name'); //检查某个 session 值是否存在$this-&gt;session-&gt;unset_userdata($array_items);删除 Session 数据 也可以单个删除 Flashdata数据 它是一种只对下一次请求有效的 session 数据， 之后将会自动被清除 12$this-&gt;session-&gt;set_flashdata('item', 'value');//设置Flashdata数据$this-&gt;session-&gt;flashdata('item');//获取Flashdata数据","link":"/2017/08/07/php-ci%E7%AC%94%E8%AE%B0/"},{"title":"php如何在删除数值型键名数组的第一个元素后，不改变其键名","text":"php在对待array提供了很多操作，它可以代替c中的栈和队列来帮助我们完成很多事情 array_push() array_push() 函数向第一个参数的数组尾部添加一个或多个元素（入栈），然后返回新数组的长度。只能添加元素的值，不能添加键值对,要想添加键值对，可以直接赋值： 1$arr[$key] = $value; //前提，$arr是一个数组 array_pop() array_pop() 函数删除数组中的最后一个元素（出栈）并返回被删除元素的值。 123$arr = array(1,2,3);echo (array_pop($arr)); //3print_r($arr); //Array ( [0] =&gt; 1 [1] =&gt; 2 ) array_shift() array_shift() 函数删除数组中第一个元素（出队），并返回被删除元素的值。 如果键名是数字的，所有元素都会获得新的键名，从 0 开始，并以 1 递增（参见下面例子）。 123$a=array(0=&gt;&quot;red&quot;,1=&gt;&quot;green&quot;,2=&gt;&quot;blue&quot;);echo array_shift($a);print_r ($a); //redArray ( [0] =&gt; green [1] =&gt; blue ) 如果不想改变其键名，博主用了一个比较笨的方法，把数组转化为对象，删除对象的第一个元素之后，再将对象转化为数组 12345678910111213141516171819202122232425262728293031323334$arr = array(&quot;1&quot;=&gt;&quot;red&quot;,&quot;2&quot;=&gt;&quot;green&quot;,&quot;3&quot;=&gt;&quot;blue&quot;);print_r($arr); //Array ( [1] =&gt; red [2] =&gt; green [3] =&gt; blue )$arr = array_to_object($arr);print_r($arr); // stdClass Object ( [1] =&gt; red [2] =&gt; green [3] =&gt; blue )foreach ($arr as $k =&gt; $value){ unset($arr-&gt;$k);//删除对象的$k属性，此处即把第一个属性删掉 break;}$arr = object_to_array($arr);print_r($arr); //Array ( [2] =&gt; green [3] =&gt; blue )//数组转化为对象function array_to_object($array) { if (is_array($array)) { $obj = new StdClass(); foreach ($array as $key =&gt; $val){ $obj-&gt;$key = $val; } } else { $obj = $array; } return $obj;}//对象转化为数组function object_to_array($object) { if (is_object($object)) { foreach ($object as $key =&gt; $value) { $array[&quot;$key&quot;] = $value; } } else { $array = $object; } return $array;} array_unshift() array_unshift() 函数用于向数组插入新元素。新数组的值将被插入到数组的开头（入队）,返回数组中元素的个数。 数值键名将从 0 开始，以 1 递增。字符串键名将保持不变。 123456$a=array(0=&gt;&quot;red&quot;,1=&gt;&quot;green&quot;);array_unshift($a,&quot;blue&quot;);print_r($a); //Array ( [0] =&gt; blue [1] =&gt; red [2] =&gt; green )$a=array(&quot;a&quot;=&gt;&quot;red&quot;,&quot;b&quot;=&gt;&quot;green&quot;);array_unshift($a,&quot;blue&quot;);print_r($a); //Array ( [0] =&gt; blue [a] =&gt; red [b] =&gt; green )","link":"/2018/02/06/php%E5%A6%82%E4%BD%95%E5%9C%A8%E5%88%A0%E9%99%A4%E6%95%B0%E5%80%BC%E5%9E%8B%E9%94%AE%E5%90%8D%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%90%8E%EF%BC%8C%E4%B8%8D/"},{"title":"windows下好用的命令框：cmder","text":"cmder cmder是一个增强型命令行工具，不仅可以使用windows下的所有命令，更爽的是可以使用linux的命令,shell命令。 安装包 可以在官网 直接下载 下载后解压即可使用 修改命令提示符λ为$ 进入cmder文件夹下的vendor文件夹，修改clink.lua文件中第42行（不同版本可能存在差异）中{lamb}修改为$ 修改前： 1local cmder_prompt = &quot;\\x1b[1;32;40m{cwd} {git}{hg}{svn} \\n\\x1b[1;39;40m{lamb} \\x1b[0m&quot; 修改后： 1local cmder_prompt = &quot;\\x1b[1;32;40m{cwd} {git}{hg}{svn} \\n\\x1b[1;39;40m$ \\x1b[0m&quot; 添加到环境变量 右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;编辑-&gt;浏览。选中cmder.exe所在的文件夹 添加到右键菜单 如果用cmd，cmd管理员命令下，进入cmder.exe所在目录，输入Cmder.exe /REGISTER ALL 如下： 如果用windows powershell，windows powershell管理员下，进入cmder.exe所在目录，输入.\\Cmder.exe /REGISTER ALL 显示中文 win+alt+p打开Settings Settings –&gt; Startup –&gt; Environment，添加：set LANG=zh_CN.UTF8，重启cmder 这样ls可以正确显示中文，但ls more还是会出现乱码。 改为set LANG=zh_CN.GBK可以解决这个问题。","link":"/2018/01/29/windows%E4%B8%8B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E6%A1%86%EF%BC%9Acmder/"},{"title":"wordpress自动升级遇到的问题，正在更新和文件权限问题","text":"自动升级时，提示 “另一项更新正在进行”。 这是由于在升级Wordpress时，Wordpress会在数据库wp_options表中增加core_updater.lock记录。如中途打断Wordpress升级，这个记录会留在数据库中。当下次升级时，Wordpress检测到此记录的存在就会返回”另一更新正在进行”。可通过以下方法解决： 通过MySQL数据库管理工具（比如 phpMyAdmin），在 wp_options表中找到 core_updater.lock记录并将这一列数据删除。具体SQL命令如下： 查询： 1select * from wp_options where option_name='core_updater.lock' 删除： 1delete from wp_options where option_name='core_updater.lock' 自动升级时，由于权限问题升级失败 博主用的oneinstack集成安装的lamp，所以权限分配有些问题。大家可能出现这种情况 这是由于权限不够，网上有教程说把涉及到的文件和文件夹权限改成777即，所有用户都可以读、写、执行。这样可能有安全方面的问题。其实，文件夹的权限给到755就足够了，但是为什么还是权限不够呢？ 这是因为wordpress安装的时候，文件所有者是root，而网站执行操作的是www，所以这里只需要把对应的wordpress文件夹及其子文件夹的所有者改为www就可以啦 打开终端命令，在worpress上级文件夹内写chmod -R 755 wordpress 最后一个替换成自己要改的文件夹名就可以啦","link":"/2017/12/26/wordpress%E8%87%AA%E5%8A%A8%E5%8D%87%E7%BA%A7%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E6%AD%A3%E5%9C%A8%E6%9B%B4%E6%96%B0%E5%92%8C%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/"},{"title":"栈的部分操作","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758“#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//函数结果状态码#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2#define STACK_INIT_SIZE 100#define STACKINCREMENTtypedef int Status;typedef int elemtype;typedef struct{elemtype *top;elemtype *base;int stacksize;}Sqstack;Status InitStack(Sqstack *S){S-&gt;base = (elemtype *)malloc(STACK_INIT_SIZE*sizeof(elemtype));if(!S-&gt;base) exit(OVERFLOW);S-&gt;top = S-&gt;base;S-&gt;stacksize = STACK_INIT_SIZE;return OK;}//初始化栈Status Stackempty(Sqstack *S){if(S-&gt;top == S-&gt;base)return TRUE;elsereturn FALSE;}Status Push(Sqstack *S,elemtype *e){if(S-&gt;top-S-&gt;base&gt;=S-&gt;stacksize){S-&gt;base = (elemtype*)realloc(S-&gt;base,(S-&gt;stacksize+STACKINCREMENT)*sizeof(elemtype));if(!S-&gt;base) exit(OVERFLOW);S-&gt;top = S-&gt;base + S-&gt;stacksize;S.stacksize = S.stacksize + STACKINCREMENT;}*S-&gt;top++ = e;return OK;}Status Pop(Sqstack *S,elemtype *e){if(Stackempty(Sqstack *S)){return ERROR;}e = *–S-&gt;top;return OK;}int main(){return 0;}“","link":"/2017/10/17/%E6%A0%88%E7%9A%84%E9%83%A8%E5%88%86%E6%93%8D%E4%BD%9C/"},{"title":"记一次服务器无法启动后，从服务器取出数据","text":"事件起因 第一天 周三收到同学消息，说网站后台登录不上去了，打开网页一看，是mysql连接报错，远程连接进入服务器，提示 Read-only file System ，如下图所示： 后来尝试运行各种命令都没有效果，网上一搜，说是硬盘变成只读，不可写入，我随便打开文件修改一下，果然报错：无法写入。尝试用网上的教程：用fsck修复一下： f**k! 怎么回事？怎么跟网上的结果不一样啊？怎么感觉问题越来越严重了呢？之后我再输几个命令，全是input/output error。继续网上查资料，说是硬盘的故障，内核无法从磁盘上读取二进制程序 ，下次启动时系统自动 fsck 可能会更正磁盘错误，但首先需要使系统重启 。reboot不管用，让我直接用内核重启，于是，我又作死地输入了以下命令： two thousand years later… 卧槽？ 连不上服务器了，心里有一千个草泥马在奔腾。行了，今天先这样吧，明天去机房重启一下。。。 没事不要瞎搞，更不要随便相信网上的东西！！！ 第二天 周四来到信息楼，跟老师说明情况后，老师示意我去机房找找去，找了一圈没找到；两圈，没找到。我说老师您知不知道我们的服务器在哪？答曰：我只管开关机房的门，别的管不了。。。无奈又回去找了两圈，还是没找到，去问上一届的学长，学长也不太清楚，又去问了上上届的学长，才了解到服务器是虚拟机。。。What？怎么没人跟我说过啊？然后直接找网络信息中心老师，让他帮忙操作。 网站的信息，一定要传承下去。不仅仅是资料、信息，还有思想、情怀，不然，以后想找也找不到了。就比如最近的一次，更换备案信息需要域名注册者信息，现在一个多月了，还不知道域名是用谁的信息注册的，到现在域名也还没更换备案，用了12年的域名到现在没法用了。 第五天 周天早上，网络信息中心的张老师打电话说没弄好，因为下周不在学校，所以把文件发给我先让我自己弄（到这里我的心已经凉了半截了，你都弄不好，靠我只会几个linux命令怎么修？）。借了移动硬盘去了信息楼。从他那里得知，是因为主服务器的两个控制器中的一个控制器A出问题了，两控制器之间的通信在12秒钟的时间内发生了中断，正好有部分服务器在这期间进行了读写操作，然后系统都变成只读文件系统了。不过windows系统适应性较好，没出问题，出问题的是部分linux（这里也能看出，linux操作系统不一定就比windows好）。他在那里一番操作，大致明白了意思是磁盘文件都没问题，是管理某个分区的superblock损坏。给了我两个参考文章，因为开不开机，一直不知道命令在哪里运行。 经过 回去之后联系指导老师，指导老师联系了网安实验室的赵老师，赵老师给了很多指导性的意见，首先是想通过加载内核文件来启动系统，不过尝试了几次都失败了，给了一个建设性建议，用linux的救援模式启动，然后通过硬盘挂载先把数据弄出来。 期间尝试了几个办法：下载Ext2 Volume Manager软件，虚拟磁盘映射到物理磁盘；新建一个虚拟磁盘，然后用另一个系统加载它。然而都读不出来磁盘的数据部分。 正文 虚拟机用救援模式启动，这里我不再赘述，网上一找就能找到一大堆。 给虚拟机增加一个虚拟磁盘。 激活虚拟分区 首先查看一下逻辑分区的状态：lvscan 发现磁盘是inactive状态，那就先把他们转换为Active状态:vgchange -ay /dev/VolGroup 此时虚拟分区已经变成Active状态了。 查看磁盘分区信息 parted -l &gt; parted 查看所有磁盘状态和文件系统类型 &gt; parted 是因为一个屏幕显示不完，输出到文件parted。如果卡在某个地方直接Ctrl+C退出就可以。 vi parted 这里看到我们有两个磁盘，一个sda，一个sdb，通过对增加虚拟磁盘之前的状态可以知道,sda是原有磁盘，sdb是新加的磁盘，unrecognized disk label说明磁盘还没分区。下面三个是逻辑分区 root、home、swap。我们待恢复的数据在 root和home里面。它们的文件系统类型为ext4。 挂载root分区到磁盘 首先，新建一个文件夹用于挂载分区。 mkdir /myhome 然后挂载home分区到/myhome mount -t ext4 /dev/mapper/VolGroup-lv_home /myhome -t是指定文件系统类型，如果parted没有显示出来可以ext2、ext3、ext4分别试一下。后面第一个路径是虚拟分区的路径，parted -l可以看到，第二个是要挂载的目录。 没有报错，证明挂载成功了，看一下。 看到我home里面的文件都取出来了 新磁盘分区并格式化 fdisk /dev/sdb 这里sdb是我新加的磁盘，一定要确定不是你原来的磁盘，不然格式化之后什么东西都没了 到这里不要慌，按m查看帮助 我们选择n，添加一个新分区 然后选择分区个数1，索引位置默认就好，这里一路回车下去 按p查看分区表，按w进行分区并退出。 通过 parted -l 这里看到分区已经完成，但是文件系统那还是空。还需要格式化一下磁盘。分了一个区新分的区应该是sdb1,如果不放心可以fdisk -l查看一下 看到这里就是sdb1，然后以ext4格式格式化磁盘 mkfs.ext4 /dev/sdb1 好了，分区完成，接下来还是要挂载到这个设备上。 mkdir /home_back mount -t ext4 /dev/sdb1 /home_back/ 这里看到挂载成功了，接下来就可以cp复制了 取消挂载 复制完之后，用umount命令取消挂载就行了 umount /myhome umount /home_back 映射新分配的磁盘到物理机 用VMware把这块新加的磁盘映射到物理机即可读出文件，若是读不出来，可以下载Ext2 Volume Manager这个软件试一下，另外一种方式是新建一个虚拟机，把这块磁盘给加进去，然后就可以读出来了。 参考文章： 1.Linux 磁盘分区、格式化、目录挂载 2.linux的mount（挂载）命令详解 3.CentOS虚拟机如何进入救援模式? 4.玩转vmware虚拟机：如何挂载虚拟机磁盘到物理机","link":"/2019/01/22/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E5%90%8E%EF%BC%8C%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%96%E5%87%BA%E6%95%B0%E6%8D%AE/"},{"title":"迁移数据库文件到另一台服务器","text":"数据恢复 新开了一台虚拟机，把mysql/data下面的 文件进行复制替换。 复制完之后执行service mysqld start 报错：Starting MySQL… ERROR! The server quit without updating PID file (/data/mysql/mysql.pid). 如图 百度。。。一大堆方法，不管用。 突然想到 是不是权限问题？ 直接 chown -R mysql /data/mysql/ 然后 启动mysql servic mysqld start 早该想到的。。。 除了这个原因，还有可能是你的mysql配置文件my.cnf出现了问题。 注意：进行数据文件替换之后，原有数据和配置（数据库账户、部分配置）会被覆盖，所以这里是新开了一个虚拟机进行操作。 数据导出 原本用Navicat软件转储sql文件进行导出的，不过在进行数据导入的时候发现执行效率非常低，1-3s才能执行一条查询语句，通过对比Navicat转储的文件和mysqldump导出的文件可以发现，软件转储得到文件一个insert语句只插入了一条数据，而mysqldump导出的数据一条insert语句插入了很多数据： 所以还是选择mysqldump导出，效率更高 1mysqldump -u 用户名 -p 数据库 &gt; 导出文件路径 数据导入 将导出的sql文件传到要迁移的服务器 进入mysql 1mysql -u用户名 -p 选择所要恢复的目标数据库 1use 数据库名; 数据导入 1source 文件路径 Over","link":"/2019/01/22/%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"移动Web开发之rem","text":"rem(一个CSS单位) 定义：font size of the root element. 这个单位的定义和em类似，不同的是em是相对于父元素，而rem是相对于根元素。rem定义是根元素的font-size, 以rem为单位，其数值与px的关系，需相对于根元素的font-size计算，比如，设置根元素font-size=16px, 则表示1rem=16px。关于rem更多的解读，建议可以腾讯一团队的文章《web app变革之rem》。 根据这个特点，可以根据设备宽度动态设置根元素的font-size，使得以rem为单位的元素在不同终端上以相对一致的视觉效果呈现。 选取一个设备宽度作为基准，设置其根元素大小，其他设备根据此比例计算其根元素大小。比如使得iPhone6根元素font-size=16px。 设 备 设备宽度 根元素font-size/px 宽度/rem iPhone5 320 js计算所得 – iPhone6 375 16 23.4375 i6 Plus 414 js计算所得 – - 360 js计算所得 – 根元素fontSize公式：width/fontSize = baseWidth/baseFontSize其中，baseWidth, baseFontSize是选为基准的设备宽度及其根元素大小，width, fontSize为所求设备的宽度及其根元素大小 动态设置根元素fontSize 12345678910111213141516171819202122232425262728293031323334/** * 以下这段代码是用于根据移动端设备的屏幕分辨率计算出合适的根元素的大小 * 当设备宽度为375(iPhone6)时，根元素font-size=16px; 依次增大； * 限制当为设备宽度大于768(iPad)之后，font-size不再继续增大 * scale 为meta viewport中的缩放大小 */(function (doc, win) { var docEl = win.document.documentElement; var resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize'; /** * ================================================ * 设置根元素font-size * 当设备宽度为375(iPhone6)时，根元素font-size=16px; × ================================================ */ var refreshRem = function () { var clientWidth = win.innerWidth doc.documentElement.clientWidth doc.body.clientWidth; console.log(clientWidth) if (!clientWidth) return; var fz; var width = clientWidth; fz = 16 * width / 375; docEl.style.fontSize = fz + 'px'; }; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, refreshRem, false); doc.addEventListener('DOMContentLoaded', refreshRem, false); refreshRem();})(document, window); rem计算(px2rem) 对于需要使用rem来适配不同·屏幕的元素，使用rem来作为CSS单位，为了方便，可以借助sass写一个函数计算px转化为rem, 写样式时不必一直手动计算。sass函数的使用若不熟悉可看下这篇文章：如何编写自定义Sass 函数, 也可以使用sass的mixin来写，个人觉得用函数写更适合。 123456789101112131415161718/* * 此处 $base-font-size 具体数值根据设计图尺寸而定 * flexible中设置的标准是【fontSize=16px, when 屏幕宽度=375】，因此，按此标准进行计算， * 若设计图为iPhone6(375*667)的二倍稿，则$base-font-size=32px * */ @function px2rem($px, $base-font-size: 32px) { @if (unitless($px)) { @warn &quot;Assuming #{$px} to be in pixels, attempting to convert it into pixels for you&quot;; @return px2rem($px + 0px); // That may fail. } @else if (unit($px) == rem) { @return $px; } @return ($px / $base-font-size) * 1rem;}// 使用，eg:font-size: px2rem(18px); 问题思考 我之前一直在想一个问题，选取哪个设备来做基准、屏幕宽度等分为多少比较合适，设计图给多大宽度的版本？被选取作为基准的设备，应当就是前端需要设计提供的设计图版本，这样可以避免一些尺寸上的纠缠，而等分为多少等分，除了考虑方便设计，是否需要考虑其他问题？对于根元素font-size没有手动设置的情况，1rem究竟等于多少？ 了解到的一些事实： 某些Android设备会丢掉 rem 小数部分（具体是哪些设备，搜到的文章中没有说），那么1rem对应的px少些，在这些安卓设备上显示误差就会较小，当然如果不存在会丢掉小数这个问题，这一说也就不必考虑了。 未设置font-size情况下，1rem的大小具体看浏览器的实现，默认的根元素大小是font-size=16px 目前一般会选取iPhone6作为基准，设计图便要iPhone6的二倍图 当动态缩放视口为1/dpr, 计算所得的根元素fontSize也会跟着缩放，即若理想视口(scale=1), iPhone6根元素fontSize=16px; 若scale=0.5, iPhone6根元素fontSize=32px; 因此设置视口缩放应放于设置根元素fontSize之前。 注：文章转载自移动Web页面适配方案","link":"/2018/07/16/%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E4%B9%8Brem/"},{"title":"正则表达式","text":"界定符 表示一个正则表达式的开始和结束 一般在php中 使用 / 如 /[0-9]/或者#如#[0-9]#作为正则表达式的界定符 原子 正则表达式的最小匹配单位，是unicode中的一个字符 不可见原子 空格 回车 \\r 换行符 \\n 制表符 \\t 元字符 | 匹配两个或者多个分支选择 [ ] 匹配方括号中的任意一个字符 [^ ] 匹配除方括号内字符的任意字符 原子集合 . 匹配除换行符之外的任意字符 \\d 匹配任意一个十进制数字，即[0-9] \\D 匹配任意一个非十进制数字，即[^0-9] \\s 匹配一个不可见原子 \\S 匹配一个可见原子 \\w 匹配一个数字字母下划线 \\W 匹配一个非数字字母下划线 量词(连续出现) {n} 表示其前面的原子恰好出现n次 {n,} 表示其前面的原子至少出现n次 {n,m} 表示其其前面的原子出现n到m次 * 匹配0次1次或多次其之前的原子，即{0,} + 匹配1次或多次其之前的原子，即{1,} ? 匹配0次或者一次其之前的原子，即{0,1} 边界控制 ^ 限制字符串以其之后的原子开头 $ 限制字符串以其之前的原子结束 /^Duang~$/匹配以D开头并且以~结尾 模式单元 () 把括号里面的正则表达式当做一个原子来看待 修正模式 U–懒惰匹配 当匹配的内容有歧义时，贪婪匹配取最长的，懒惰模式取最短的 1234567$pattern = '/imooc.+123/U';//'前的U代表修正模式是懒惰模式，如果没有U默认为贪婪模式$subject = 'I love imooc__123123123123123123';$matches = array();preg_match($pattern,$subject,$matches);//打印结果imooc__123//去掉U 打印结果imooc__123123123123123123 i-忽略大小写 x-忽略空白 s–让元字符. 匹配包括换行符在内的所有字符","link":"/2018/02/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"首页","text":"","link":"/2017/08/05/%E9%A6%96%E9%A1%B5/"},{"title":"基础时间序列分析（统计学分析）","text":"数理统计知识 矩 原点矩：令k为正整数（或为0），a为任何实数，X为随机变量，则期望值E((X−a)k)E\\left((X-a)^{k}\\right)E((X−a)​k​​) 叫做随机变量X对a的k阶矩。如果a=0，则有E（Xk），叫做k阶原点矩，记作vk(X)v_{k}(X)v​k​​(X) ，也叫k阶矩。 vk(X)=E(Xk),k=1,2,…v_{k}(X)=E\\left(X^{k}\\right), k=1,2, \\ldotsv​k​​(X)=E(X​k​​),k=1,2,… 显然，一阶原点矩就是数学期望，即v1(X)=E(X)v_{1}(X)=E(X)v​1​​(X)=E(X) 原点矩在几何意义上可以看做随机变量到原点的距离的均值 中心距：设随机变量X的函数[X−E(X)]k(k=1,2,…)[X-E(X)]^{k}(k=1,2, \\ldots)[X−E(X)]​k​​(k=1,2,…) 的数学期望存在，则称 E{[X−E(X)]k}E\\left\\{[X-E(X)]^{k}\\right\\}E{[X−E(X)]​k​​} 为X的k阶中心矩**，**记作μk(X)\\mu_{k}(X)μ​k​​(X)，即 μk(X)=E{[X−E(X)]k},k=1,2,… \\mu_{k}(X)=E\\left\\{[X-E(X)]^{k}\\right\\}, k=1,2, \\ldots μ​k​​(X)=E{[X−E(X)]​k​​},k=1,2,… 易知，一阶中心矩恒等于零，即 μ1(X)≡0\\mu_{1}(X) \\equiv 0 μ​1​​(X)≡0 ；二阶中心矩就是方差，即 μ2(X)=D(X) \\mu_{2}(X)=D(X) μ​2​​(X)=D(X) 中心矩在几何意义上可以看做随机变量到均值点的距离的均值 协方差：用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况 期望值分别为E[X]与E[Y]的两个实随机变量X与Y之间的协方差 *Cov(X,Y)*定义为： 自协方差:特定时间序列或者连续信号Xt的自协方差是信号与其经过时间平移的信号之间的协方差。如果序列的每个状态都有一个平均数E[Xt]=μt，那么自协方差为 γ(i,j)=E[(Xi−μi)(Xj−μj)]\\gamma(i, j)=E\\left[\\left(X_{i}-\\mu_{i}\\right)\\left(X_{j}-\\mu_{j}\\right)\\right] γ(i,j)=E[(X​i​​−μ​i​​)(X​j​​−μ​j​​)] 时间序列 定义 时间序列就是一组随机变量X(t)，在一系列时刻t1,t2,t3,···tn上的一次样本实现xt1,xt2,xt3···xtn. 在任意一个时刻只有一个观察值 时间序列分析强调变量值的顺序性的重要性 时序观察值之间一般存在一定的依存关系 时间序列可以分析自身的变化规律来进行预测 平稳时间序列 定义 平稳时间序列分为严平稳和宽平稳 严平稳是一种条件比较苛刻的平稳性定义,它认为只有当序列所有的统计性质都不会随着时间的推移而发生变化时,该序列才能被认为平稳。 宽平稳是使用序列的特征统计量来定义的一种平稳性.它认为序列的统计性质主要由它的低阶矩决定,所以只要保证序列低阶矩平稳（二阶）,就能保证序列的主要性质近似稳定. 平稳时间序列的性质 均值为常数 方差存在且为常数 自协方差函数和自相关系数只依赖于时间的平移长度而与时间的起止点无关。即：$ \\gamma (t,s) = \\gamma (k,k + s - t) $ 根据这个性质，可以将二维函数简化为一维函数: γ(s−t)≜γ(t,s)\\gamma(s-t) \\triangleq \\gamma(t, s)γ(s−t)≜γ(t,s) 延迟k自协方差函数:γ(k)=γ(t,t+k)\\gamma (k) = \\gamma (t,t + k)γ(k)=γ(t,t+k) 延迟k自相关系数:ρk=γ(t,t+k)DXtDXt+k=γ(k)γ(0)\\rho_{\\mathrm{k}}=\\frac{\\gamma(t, t+k)}{\\sqrt{D X_{t} D X_{t+k}}}=\\frac{\\gamma(k)}{\\gamma(0)}ρ​k​​=​√​DX​t​​DX​t+k​​​​​​​γ(t,t+k)​​=​γ(0)​​γ(k)​​ 平稳时间序列的意义 常数均值性使得原来Xt的均值μt\\mu_{\\mathrm{t}}μ​t​​由唯一的观察值xt去估计，变成了常数均值μ\\muμ由样本观测值x1,x2,xt去估计。即 μ^=x¯=1n∑i=1nxi\\hat{\\mu}=\\bar{x}=\\frac{1}{n} \\sum_{i=1}^{n} x_{i}​μ​^​​=​x​¯​​=​n​​1​​∑​i=1​n​​x​i​​ 延迟k自协方差函数估计值 平稳性检验 一般呈趋势性或者周期性的时间序列是非平稳的时间序列 自相关图检验acf 随着延迟阶数k的增加，平稳的自相关系数ρk\\rho_{\\mathrm{k}}ρ​k​​会很快衰减向零（在两倍标准差之内） 纯随机性检验 纯随机序列 纯随机序列也叫白噪声序列，他满足以下两条性质 (1)EXt=μ(1) \\mathrm{EX}_{\\mathrm{t}}=\\mu (1)EX​t​​=μ (2)γ(t,s)={σ2,t=s0,t≠s(2) \\gamma(t, s)=\\left\\{\\begin{array}{l}\\sigma^{2}, t=s \\\\ 0, t \\neq \\mathrm{s}\\end{array}\\right. (2)γ(t,s)={​σ​2​​,t=s​0,t≠s​​ 对于任意两个不同时刻，他们之间是没有自相关关系的 白噪声序列是最简单的平稳序列 纯随机序列性质 纯随机性 方差齐性 检验 常用LB统计量： LB=n(n+2)∑k+1m(ρ^k2n−k)LB = n(n + 2)\\sum\\limits_{k + 1}^m {(\\frac{ {\\hat \\rho _k^2}}{ {n - k}})} LB=n(n+2)​k+1​∑​m​​(​n−k​​​ρ​^​​​k​2​​​​) 在R中使用Box.test(var,lag=6,type=&quot;Ljung-Box&quot;) 平稳时间序列分析 差分运算 一阶差分 二阶差分 p阶差分 k步差分 延迟算子 定义：延迟算子类似于一个时间指针，当前序列值乘以一个延迟算子，就相当于把当前序列值的时间过去拨了一个时刻 记B为延迟算子，有 xt−1=Bxtxt−2=B2xtxt−p=Bpxt\\begin{aligned} \\mathrm{x}_{t-1} &amp;=B x_{t} \\\\ \\mathrm{x}_{t-2} &amp;=B^{2} x_{t} \\\\ \\mathrm{x}_{t-p} &amp;=B^{p} x_{t} \\end{aligned} ​x​t−1​​​x​t−2​​​x​t−p​​​​​=Bx​t​​​=B​2​​x​t​​​=B​p​​x​t​​​​ 线性差分方程 AR模型 定义 自回归模型（英语：Autoregressive model，简称AR模型），是统计上一种处理时间序列的方法，用同一变数x之前各期，即x1至xt-1来预测本期xt的表现，并假设它们为一线性关系。因为这是从回归分析中的线性回归发展而来，只是不用x预测y，而是用x预测 x（自己）；所以叫做自回归。 具有如下结构的模型成为p阶自回归模型，简记为AR§: 下面三个限制条件表示： 模型的最高阶为p 随机干扰序列{εt{\\varepsilon _t}ε​t​​}为零均值白噪声序列 当期的随机干扰与过去的序列无关 当ϕ0\\phi_{0}ϕ​0​​等于0时，自回归模型又称为中心化AR§模型。 引入延迟算子，中心化AR§模型又可以表示为： Φ(B)xt=εt,Φ(B)=1−ϕ1B−ϕ2B2−⋯−ϕpBp\\Phi(B) x_{t}=\\varepsilon_{t}, \\Phi(B)=1-\\phi_{1} B-\\phi_{2} B^{2}-\\cdots-\\phi_{p} B^{p} Φ(B)x​t​​=ε​t​​,Φ(B)=1−ϕ​1​​B−ϕ​2​​B​2​​−⋯−ϕ​p​​B​p​​ 平稳性判别 AR模型是常用的平稳序列拟合模型之一，但并非所有的AR模型都是平稳的 时序图判别法 特征根判别法 平稳AR模型的每个特征根绝对值小于1 平稳域判别 ϕ1,ϕ2⋯ϕp\\phi_{1}, \\phi_{2} \\cdots \\phi_{p}ϕ​1​​,ϕ​2​​⋯ϕ​p​​ |特征根都在单位圆内 平稳AR模型的性质 均值 μ=ϕ01−ϕ1−⋯−ϕp\\mu=\\frac{\\phi_{0}}{1-\\phi_{1}-\\cdots-\\phi_{p}}μ=​1−ϕ​1​​−⋯−ϕ​p​​​​ϕ​0​​​​ 对于中心化的AR§模型，均值为0 方差 AR(1)模型 Gj={1,j=0ϕ1j,j&gt;1Var(xt)=σε21−ϕ12\\begin{array}{l} {G_j} = \\left\\{ \\begin{array}{l} 1,j = 0\\\\ \\phi _1^j,j &gt; 1 \\end{array} \\right.\\\\ Var({x_t}) = \\frac{ {\\sigma _\\varepsilon ^2}}{ {1 - \\phi _1^2}} \\end{array}​G​j​​={​1,j=0​ϕ​1​j​​,j&gt;1​​​Var(x​t​​)=​1−ϕ​1​2​​​​σ​ε​2​​​​​​ AR§模型 Gj={1,j=0∑k=11ϕ′kGj−k,j≥1ϕ′k={ϕk,k≤p0,k&gt;pVar(xt)∑j=0∞Gj2σε2\\begin{array}{l} {G_j} = \\left\\{ \\begin{array}{l} 1,j = 0\\\\ \\sum\\limits_{k = 1}^1 { { {\\phi '}_k}{G_{j - k}}} ,j \\ge 1 \\end{array} \\right.\\\\ { {\\phi '}_k} = \\left\\{ \\begin{array}{l} {\\phi _k},k \\le p\\\\ 0,k &gt; p \\end{array} \\right.\\\\ Var({x_t})\\sum\\limits_{j = 0}^\\infty {G_j^2\\sigma _\\varepsilon ^2} \\end{array}​G​j​​=​⎩​⎨​⎧​​​1,j=0​​k=1​∑​1​​ϕ​′​​​k​​G​j−k​​,j≥1​​​ϕ​′​​​k​​={​ϕ​k​​,k≤p​0,k&gt;p​​​Var(x​t​​)​j=0​∑​∞​​G​j​2​​σ​ε​2​​​​ 自协方差函数 γk=ϕ1γk−1+ϕ2γk−2+⋯+ϕpγk−p\\gamma_{k}=\\phi_{1} \\gamma_{k-1}+\\phi_{2} \\gamma_{k-2}+\\cdots+\\phi_{\\mathrm{p}} \\gamma_{k-p}γ​k​​=ϕ​1​​γ​k−1​​+ϕ​2​​γ​k−2​​+⋯+ϕ​p​​γ​k−p​​ AR(1) γk=ϕ1kσε21−ϕ12{\\gamma _k} = \\phi _1^k\\frac{ {\\sigma _\\varepsilon ^2}}{ {1 - \\phi _1^2}}γ​k​​=ϕ​1​k​​​1−ϕ​1​2​​​​σ​ε​2​​​​ AR(2) {γ0=1−ϕ2(1+ϕ2)(1−ϕ1−ϕ2)(1+ϕ1−ϕ2)γ1=ϕ1γ01−ϕ2γk=ϕ1γk−1+ϕ2γk−2,k≥2\\left\\{\\begin{array}{l}\\gamma_{0}=\\frac{1-\\phi_{2}}{\\left(1+\\phi_{2}\\right)\\left(1-\\phi_{1}-\\phi_{2}\\right)\\left(1+\\phi_{1}-\\phi_{2}\\right)} \\\\ \\gamma_{1}=\\frac{\\phi_{1} \\gamma_{0}}{1-\\phi_{2}} \\\\ \\gamma_{k}=\\phi_{1} \\gamma_{k-1}+\\phi_{2} \\gamma_{k-2}, \\quad k \\geq 2\\end{array}\\right.​⎩​⎪​⎨​⎪​⎧​​​γ​0​​=​(1+ϕ​2​​)(1−ϕ​1​​−ϕ​2​​)(1+ϕ​1​​−ϕ​2​​)​​1−ϕ​2​​​​​γ​1​​=​1−ϕ​2​​​​ϕ​1​​γ​0​​​​​γ​k​​=ϕ​1​​γ​k−1​​+ϕ​2​​γ​k−2​​,k≥2​​ 自相关系数 分段 分类 预测 符号化","link":"/2021/03/14/timeseries/"},{"title":"将博客从wordpress迁移到hexo并托管到github","text":"从wordpress导出文件 打开wordpress进入后台管理⇒\\Rightarrow⇒导出⇒\\Rightarrow⇒所有内容 得到一个xml文件，此文件即为wordpress的备份。 安装Hexo 环境要求 nodejs git 使用npm安装hexo 1npm install -g hexo-cli 建站及配置 新建博客项目 123hexo init 项目名cd 项目名npm install 参考https://hexo.io/zh-cn/docs/configuration配置网站信息 常用指令 新建博文 1hexo new [layout] &lt;title&gt; 生成静态文件 1hexo g 启动服务器 1hexo server 迁移wordpress备份到hexo 安装hexo-migrator-wordpress 插件。 1npm install hexo-migrator-wordpress --save 安装完成后，执行命令来迁移所有文章，source选择导出的wordpress备份文件 1hexo migrate wordpress &lt;source&gt; 迁移完成运行hexo g可能会报错，这是因为hexo无法完美的迁移wordpress，某些文章需要手动修改一下 如果报错可以定向到某个文件，可以前往source/_posts目录定位错误的.md文件 若报错未知path，那只能一个文件一个文件地打开找 建议所有文章都打开检查一下，因为很多文章，特别是涉及到代码块的文章迁移效果都不太好 在markdown文件中添加&lt;!-- more --&gt;来使首页显示文章概览而不是全文 在markdown顶部注释添加toc: true来使文章显示目录 部署至github 此处默认你会使用github 新建respository，项目名命名为你的用户名.girthub.io 安装git自动部署插件 1npm install hexo-deployer-git --save 修改配置 12345deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 以上配置均不带括号 branch默认为gh-page 清除静态文件并部署至github 12hexo cleanhexo deploy 以后部署就无需清除了 避免每次更新输入账号密码 选择ssh连接github，即git@github.com:xxxxxxxxxxxxxx 更换主题 主题列表 https://hexo.io/themes/ 推荐主题 hexo-theme-icarus(在用) hexo-theme-next(Star最多) 使用方法（以icarus为例） 安装 12npm install hexo-theme-icarushexo config theme icarus 运行 1hexo server 可能会报错，报什么错就按照上面的错误提示执行，自行解决 配置 各主题的配置方法不同，请按照对应的教程进行配置 本主题可参考Icarus用户指南 - 主题配置 更换为自己的域名 域名解析 前往自己域名所在管理平台，添加一条解析记录 记录类型：CNAME 记录值：你的github名.github.io 配置_config文件 打开hexo目录下的_config.yml文件，找到URL，将其指向域名地址 我的是https://www.huhuapin.cn 修改CNAME文件 打开hexo/source目录下的CNAME文件（没有请新建，无后缀） 在其中填写域名地址 图片迁移至七牛云 七牛云注册实名认证后会送10GB的对象存储空间 导出图片 登录服务器，wordpress目录下wp-content，复制uploads文件夹到本地。 在七牛云新建存储空间 存储空间名称：不可重复 存储区域：随便选 访问控制：公开 绑定自己的域名（可选） 自定义CDN加速域名下绑定域名 加速域名：填写你自己的域名，我的是static.huhuapin.cn 缓存配置：使用推荐配置 创建 之后会给一个cname值。 添加域名解析（接上条可选） 需要在你购买域名的平台，添加一条CNAME解析记录，值即为上文的cnme值 绑定SSL证书（接上条可选） 可以在七牛云申请，也可以在域名管理平台申请。我这里选择的后者 先进入到SSL证书，申请免费证书。 绑定域名填写自己分配到七牛云的域名，我的是static.huhuapin.cn 找到我的证书，下载 回到七牛云，打开对象存储→空间管理→域名→详情→找到HTTPS并修改。 选择本地证书 内容：复制下载下来的pem文件内容全部粘贴进去 密钥：复制.key文件内容全部粘贴进去 确定上传并确认。 图片上传至七牛云 1.根据自身环境下载对应的图形化工具kodo Browser客户端并解压 https://developer.qiniu.com/kodo/5972/kodo-browser 2.打开软件,通过七牛控制台个人中心获取 AK/SK 3.拖动备份的图片文件夹至目录下，上传任务就会自动添加了。 批量修改hexo图片链接 参考博文https://blog.csdn.net/qq_40832960/article/details/115353014 自用代码,需要修改第34行代码 123456789101112131415161718192021222324252627282930313233343536373839import mimetypesimport osimport regexif __name__ == '__main__': p = input(&quot;输入hexo的source目录&quot;) # image path like D:\\hexo\\hexo\\source # 去尾 if p.endswith(&quot;\\\\&quot;): p = p[:len(p) - 1] image_p = p + &quot;\\\\images&quot; post_p = p + &quot;\\\\_posts&quot; # 查看博文目录是否存在 if not os.path.exists(post_p): print(&quot;路径下没_posts路径，请重新输入&quot;) exit(1) else: os.chmod(p, 777) # 查看图片目录是否存在 if not os.path.exists(image_p): os.makedirs(p + &quot;\\\\images&quot;) else: os.chmod(p, 777) # 循环目录下每一个.md文件 for filename in os.listdir(post_p): if filename.endswith(&quot;.md&quot;): print(filename) path = post_p + &quot;\\\\&quot; + filename # 以utf8编码读取 f = open(path, &quot;r&quot;, encoding='utf8', errors='ignore') i = 0 content = f.read() f.close() # 匹配markdown中的图片 即 ![tag](url) new_text = regex.sub(r&quot;http[s]?://www.huhuapin.cn/wp-content/&quot;,&quot;http://static.huhuapin.cn/&quot;,content) print(new_text) # 写入文章文件 f = open(path, &quot;w&quot;, encoding=&quot;utf8&quot;) f.write(new_text) f.close() 定制修改 icarus4.0之后主题都放在了node_modules，要想修改自己的网站只能去修改node_modules里的文件，虽然这不是一个好办法，但先凑合着用吧 添加备案号 打开hexo/node_modules/hexo-theme-icarus/layout/common/footer.jsx 43行左右 12345{showVisitorCounter ? &lt;br /&gt; : null}{showVisitorCounter ? &lt;span id=&quot;busuanzi_container_site_uv&quot;dangerouslySetInnerHTML={{ __html: visitorCounterTitle }}&gt;&lt;/span&gt; : null}{/* 下面为新增 */}&lt;a href=&quot;http://beian.miit.gov.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鲁ICP备17033420号&lt;/a&gt; 将其改成你的备案号 更换cdn _config.icarus.yml： 1234providers: cdn: loli fontcdn: loli iconcdn: loli 其他常见问题 公式渲染问题： 如何在HEXO中渲染Latex数学公式（注意安装markdown-it-katex） 公式推荐使用mathpix，可以截图识别。mathtype公式不能很好的匹配。 图片自动上传至七牛云： Typora 使用Upload Image将图片上传到七牛云服务器上 Typora自动上传图片配置，集成PicGo-Core，文件以时间戳命名（给文件添加后缀前缀） 参考配置文件 1234567891011121314151617181920{ &quot;picBed&quot;: { &quot;uploader&quot;: &quot;qiniu&quot;, // 代表当前的默认上传图床为 SM.MS, &quot;qiniu&quot;: { &quot;accessKey&quot;: &quot;xxx&quot;, &quot;secretKey&quot;: &quot;xxx&quot;, &quot;bucket&quot;: &quot;huhuapin-cn&quot;, // 存储空间名 &quot;url&quot;: &quot;https://static.huhuapin.cn&quot;, // 自定义域名 &quot;area&quot;: &quot;z1&quot;, // 存储区域编号,我的是华北 &quot;options&quot;: &quot;&quot;, // 网址后缀，比如？imgslim &quot;path&quot;: &quot;uploads/&quot; // 自定义存储路径，比如 img/ } }, &quot;picgoPlugins&quot;: { &quot;picgo-plugin-super-prefix&quot;: true }, // 为插件预留 &quot;picgo-plugin-super-prefix&quot;: { &quot;prefixFormat&quot;: &quot;YYYY/MM/&quot; } //super-prefix插件配置} 参考 Hexo Icarus Hexo博客icarus主题定制篇","link":"/2021/06/14/migirate-wordpress-to-hexo-on-github/"},{"title":"2021-06-随笔","text":"​ 自从19年开始考研，就很少写博客了。到20年毕业，腾讯云服务器学生优惠到期，所以也就没有续费，不过当时手动把wordpress的内容备份下来了。于是才有了现在从hexo重新部署一下博客。 ​ 为了重新部署，前前后后花了大约一周的时间，主要浪费在icarus主题和latex公式上了。Next主题也挺好看的，不过用的人比较多，不想太千篇一律。所以选了icarus主题，在这个主题上也踩了不少坑。","link":"/2021/06/14/2021-06-easy/"},{"title":"异常检测综述","text":"定义 ​ 时序异常检测通常形式化为根据某种标准或正常信号寻找离群数据点。有很多异常类型，从商业角度来说最重要的类型，包括意料之外的峰谷、趋势变动、水平变化。 ​ 基本上，异常检测算法要么将每个时间点标记为异常/非异常，要么预测某一点的信号，并测试这一点的值和预测值的偏离程度，以认定异常。 异常分类 innovational outlier (IO):造成离群点干扰不仅作用于X(T)，而且影响T时刻以后序列的所有观察值。 additive outlier (AO):造成这种离群点的干扰，只影响该干扰发生的那一个时刻T上的序列值，而不影响该时刻以后的序列值。 level shift (LS):造成这种离群点的干扰是在某一时刻T，系统的结构发生了变化，并持续影响T时刻以后的所有行为，在数列上往往表现出T时刻前后的序列均值发生水平位移。 temporary change (TC)：造成这种离群点的干扰是在T时刻干扰发生时具有一定初始效应，以后随时间根据衰减因子的大小呈指数衰减。 常见方法 STL分解（统计方法） ​ STL(Seasonal and Trend decomposition using Loess )是以鲁棒局部加权回归作为平滑方法的时间序列分解方法。 ​ 存在季节性因素的时间序列数据可以被分解为趋势因子(Trend)、季节性因子(Seasonal)、和随机因子/残差(Irregular)。此时可以通过相加模型或者相乘模型来分解数据。 相加模型：Yt = Trendt + Seasonalt + Irregulart 相乘模型：Yt = Trendt x Seasonalt x Irregulart 在R中，stl()可以很好的处理相加模型，至于相乘模型，仅需要进行一下对数变换就可以转化为相加模型了。 ​ 数据如果有异常，都会体现在残差数据集中。我们怎么从残差数据中早出有问题的数据时间点呢？ ​ 我们可以利用3-sigma原则：当残差数据近似正态分布时，我们计算出残差数据集的标准差，如果数据点与均值的差值在3倍标准差以外，则认为是异常点。 ARIMA（统计方法） ​ 自回归移动平均模型（ARIMA）是一种非常强大的时间序列拟合模型，它可以对非平稳的无季节效应的时间序列进行拟合和预测。 AR模型 AR模型（Autoregressive model）即自回归模型，用同一变数x之前各期，即xt-p至xt-1来预测本期xt的表现，并假设它们为一线性关系. 描述当前值与历史值之间的关系，用变量自身的历史时间数据对自身进行预测 AR§模型结构：xt=ϕ0+ϕ1xt−1+ϕ2xt−2+⋯+ϕpxt−p+εtx_{t}=\\phi_{0}+\\phi_{1} x_{t-1}+\\phi_{2} x_{t-2}+\\cdots+\\phi_{\\mathrm{p}} x_{t-p}+\\varepsilon_{t}x​t​​=ϕ​0​​+ϕ​1​​x​t−1​​+ϕ​2​​x​t−2​​+⋯+ϕ​p​​x​t−p​​+ε​t​​ PACF，偏自相关函数（决定p值） MA模型 MA模型（moving average model），即移动平均模型，序列当前时刻的时序值是过去q阶白噪声的线性组合 移动平均模型关注的是自回归模型中的误差项的累加，移动平均法能有效地消除预测中的随机波动 MA(q)模型结构：xt=μ+εt−θ1εt−1−θ2εt−2−⋯−θqεt−qx_{t}=\\mu+\\varepsilon_{t}-\\theta_{1} \\varepsilon_{t-1}-\\theta_{2} \\varepsilon_{t-2}-\\cdots-\\theta_{q} \\varepsilon_{t-q}x​t​​=μ+ε​t​​−θ​1​​ε​t−1​​−θ​2​​ε​t−2​​−⋯−θ​q​​ε​t−q​​ ACF，自相关函数（决定q值） ARMA模型 ​ ARMA模型就是二者的结合，是目前最常用的平稳序列拟合和预测模型。 ARMA(p,q)模型结构：xt=ϕ0+ϕ1xt−1+⋯+ϕpxt−p+εt−θ1εt−1−⋯−θqεt−qx_{t}=\\phi_{0}+\\phi_{1} x_{t-1}+\\cdots+\\phi_{p} x_{t-p}+\\varepsilon_{t}-\\theta_{1} \\varepsilon_{t-1}-\\cdots-\\theta_{q} \\varepsilon_{t-q}x​t​​=ϕ​0​​+ϕ​1​​x​t−1​​+⋯+ϕ​p​​x​t−p​​+ε​t​​−θ​1​​ε​t−1​​−⋯−θ​q​​ε​t−q​​ ARIMA模型 ​ ARMA模型只适用于平稳性序列，那么如何拟合非平稳序列呢？ ​ 差分运算具有强大的确定性信息提取能力，许多非平稳序列差分后会显示出平稳序列的性质。 ​ 根据这个特点，我们就可以将非平稳序列进行差分运算后变为平稳序列，在用ARMA模型拟合。这就是ARIMA模型（Autoregressive Integrated Moving Average model），即自回归差分移动平均模型。 ​ ARIMA共有三个参数，p,d,q。可分别根据PACF、差分运算、ACF得到。 建模步骤： 在R中，arima(ts,order=c(p,d,q)),forecast包中有一个函数auto.arima(ts)可以实现最优ARIMA模型的自动选取 预测:forecast(fit,n)，fit为拟合模型,n为向后预测的时间点个数。一般向后预测越多，结果越不准确。 1234567&gt;forecast(fit,3) Point Forecast Lo 80 Hi 80 Lo 95 Hi 951971 816.1813 634.1427 998.2199 537.7773 1094.5851972 835.5596 640.8057 1030.3136 537.7091 1133.4101973 840.4889 641.5646 1039.4132 536.2604 1144.717&gt; plot(forecast(fit,3),xlab=&quot;年份&quot;,ylab=&quot;流量&quot;)&gt; 深灰色表示80%的置信区间，浅灰色表示90%的置信区间。 异常检测就可以将预测结果和实际结果进行比较，如果实际值在置信区间外，可以认定为异常。 至于带季节性的非平稳序列，可以通过STL分解得到残差数据，再对其进行预测。 R中也有简单的实现，只需在arima()中增加一个参数seasonal就可以了。 使用R中的tsoutliers包可以方便地检测时间序列中的离群值 LOF（机器学习方法） ​ 对于C1集合的点，整体间距，密度，分散情况较为均匀一致，可以认为是同一簇；对于C2集合的点，同样可认为是一簇。o1、o2点相对孤立，可以认为是异常点或离散点。现在的问题是，如何实现算法的通用性，可以满足C1和C2这种密度分散情况迥异的集合的异常点识别。 定义 d(p,o):两点p,o之间的距离 k-distance:第k距离 ​ 对于点p的第k距离dk§ = d(p,q)，其中q是距离p第k远的点 第k距离邻域NK§，就是p的第k距离即以内的所有点，包括第k距离。 reach-distance：可达距离 ​ 点o到点p的第k可达距离:rech-distk(p,o) = max{d(p,o),dk(o)} local reachability density：局部可达密度 点p的局部可达密度表示为： \\operatorname{lrd}_{k}(p)=1 /\\left(\\frac{\\sum_{o \\in N_{k}(p)} r e a c h-\\operatorname{dist}_{k}(p, o)}{\\left|N_{k}(p)\\right|}\\right) ​ 表示点p的第k邻域内点到p的平均可达距离的倒数。 ​ 局部可达密度与总体密度类似，只不过是用k距离邻域计算的，所以称为“局部”。如果p是孤立点，那么点o到点p的可达距离会取到o,p的实际距离，这样计算出来结果就要小。 local outlier factor：局部离群因子 ​ 点p的局部离群因子表示为： L O F_{k}(p)=\\frac{\\sum_{o \\in N_{k}(p)} \\frac{\\operatorname{lrd}_{k}(o)}{l_{r d_{k}(p)}}}{\\left|N_{k}(p)\\right|} = \\frac{\\sum_{o \\in N_{k}(p)} l r d_{k}(o)}{\\left|N_{k}(p)\\right|} / l r d_{k}(p) ​ 表示点p的邻域点 Nk§Nk§的局部可达密度与点p的局部可达密度之比的平均数。 ​ 如果这个比值越接近1，说明p的其邻域点密度差不多，p可能和邻域同属一簇；如果这个比值越小于1，说明p的密度高于其邻域点密度，p为密集点；如果这个比值越大于1，说明p的密度小于其邻域点密度，p越可能是异常点。 在R中使用： 12345library(DMwR)lofactor(df, k = 5)#使用LOF算法计算局部离群点因子#df为数据集#k参数为LOF公式中的k，按照具体情况自行设置。 应用到时间序列即不考虑时间前后相关性，以孤立散点进行检测。 LSTM ​ LSTM( long short term memory)即长短记忆神经网络，是为了解决RNN网络只能保留近期信息而设计出来的网络结构，它可以选择性地记住或遗忘历史信息。 黄色的框代表神经网络层，是整个网络中非常关键的一部分 Xt代表输入信息，是一个时间点的全部信息 ht代表输出信息 一个绿色框代表一个细胞（cell）,顶部贯穿细胞的横线表示细胞状态，它选择性地保留了历史的输入信息 遗忘门 ​ 遗忘门决定遗忘哪些信息，它的作用就是遗忘掉老的不用的旧的信息，遗忘门接收上一时刻输出信息ht−1 和当前时刻的输入xt，然后得到一个遗忘矩阵ft来决定遗忘过去信息Ct-1的哪些部分。 输入门 ​ 它决定了从新的信息中存储哪些信息到细胞状态中去。即产生要更新的信息。 ​ sigmoid 层和tanh层分别接受两个输入，产生it（决定了要更新哪些信息）和C~t\\tilde{C}_{t}​C​~​​​t​​(决定了信息内容)，然后更新细胞状态： 输出门 ​ 首先利用输出门（sigmoid层）产生一个输出矩阵Ot,决定输出当前状态Ct 的哪些部分。接着状态Ct 通过tanh层之后与Ot 相乘，成为输出的内容ht LSTM-AE LSTM-AE就是将自编码器的编码和解码部分都用LSTM来代替，既可以实现降维，也可以缩短序列长度，提取信息。 Encoder：结合LSTM的性质， 在任意时刻j(i−4&lt;j&lt;i)j(i-4&lt;j&lt;i)j(i−4&lt;j&lt;i)的隐含状态JjenJ_{j}^{e n}J​j​en​​,同时受到当前时刻的输入和过去时刻隐含状态的影响。注意，最终只有i时刻的隐含状态传递给了decoder部分。所以，满足： Decoder: 与encoder的过程相反，decoder从i时刻逐一向i-4时刻遍历。所以当前时刻的隐含状态会受到当前时刻和下一个时刻隐含状态的影响","link":"/2021/06/27/time-series-anomalies-detection/"},{"title":"论文阅读总结","text":"GAN GAN-based Anomaly Detection and Localization of Multivariate Time Series Data for Power Plant 简介 ​ 发表在2020 IEEE International Conference on Big Data and Smart Computing。 每个时间步长变量之间的相似性来将多元时间序列数据转换成距离图像，通过变量之间的相位差捕捉到多维信息，也捕捉了时间信息。然后利用基于卷积结构的GAN网络，对距离图像进行生成和鉴别。通过鉴别器鉴别真实数据和生成数据的损失来确定异常。使用了电厂产生的高维数据进行试验。 网络结构 LSTM-Based VAE-GAN for Time-Series Anomaly Detection(可做参考) 简介 ​ 文章发布于2020sensors期刊，使用自编码器作为GAN的生成网络，LSTM网络作为GAN的鉴别网络，其中，自编码器也是LSTM构成的。异常值通过自编码器重构损失和鉴别器的得分共同确定。 对比实验 LSTM-AE(LSTM-AE第三篇) LSTM-VAE MAD-GAN 效果要优于以上三种，特别是在引空间较小时，效果明显。但耗时要比LSTM-AE高出将近一倍。 网络结构 LSTM-AE Outlier Detection for Multidimensional Time Series using Deep Neural Networks（参考价值高） 简介 ​ 文章发表在2018IEEE MDM,作者先使用时间序列富集模块来丰富时间序列的向量特征（滑动窗口内的DOR,滑动窗口间的DON，平均值(MEA)、最小值(MIN)、最大值(MAX)、25%-四分位数(25Q)、50%-四分位数(50Q)、75%四分位数(75Q)、标准偏差(STD)和峰峰值(P2P)。），然后输入自编码器网络中，基于重构误差来识别异常。自编码器的网络用了两种方式来实现，一个是2D-CNN。另一个是LSTM。 ​ 文章提到：时间序列的变化可能是由于上下文的变化。例如，车辆突然急剧增加速度可能是由于从住宅道路移动到高速公路，这并不代表异常点。在识别异常值时考虑上下文信息可以提高异常值检测性能。，这种上下文信息经常用分类值来描述。常用的one-hot编码在面对分类类别较多时计算量增加，而且没有捕捉到类别之间的相似之处。嵌入方法C. Guo and F. Berkhahn, “Entity embeddings of categorical variables,” CoRR, vol. abs/1604.06737, 2016 对比试验 LOF OC-SVM 网络结构 Unsupervised Learning of Video Representations using LSTMs(参考价值高) 简介 ​ 这是一遍将LSTM-AE应用于视频领域的论文，视频由连续的帧构成，难点在于如何识别动作运动轨迹和预测。作者希望通过训练LSTM-AE模型来重构输入的帧和预测将来的帧。对于重构模型，应该更多的学习整体的分别特征，而预测模型应该重点关注视频最后几帧。 ​ 使用比较简单的数据集MNIST数字变换动作进行训练和测试，使用前10帧重构、预测后10帧，lstm单元设置为2048个，通过比较可以发现，二层的lstm结构要优于一层的结构，带有条件输入预测的要优于不带条件输入的结果。 ​ 而在自然图像数据集上，模型重构和预测的表现都不太理想。通过增加LSTM单元到2048后，重构结果有所提升，但仍单无法令人满意。 ​ 如果预测步长增加，比如输入10帧而预测100帧，可以发现在前期预测尚可，到后面就完全模糊。 ​ 模型在Out-of-domain Inputs（训练中是两个数字，而测试包含一个和三个数字）中也表现出可以接受的成绩，在低特征下表现更好。 论文解析:https://blog.csdn.net/qq_21190081/article/details/64160465 网络结构 LSTM-based Encoder-Decoder for Multi-sensor Anomaly Detection 简介 比较基础的LSTM-AE框架模型。也是通过重构误差来检测异常。 网络结构 TCN A Time Convolutional Network Based Outlier Detection for Multidimensional Time Series in Cyber-Physical-Social Systems 简介 ​ TCN即时间卷积网络，一种新型的可以用来解决时间序列预测的算法，结合了CNN和RNN优点，可以并行大规模处理的神经网络结构，被认为是LSTM的替代。 ​ TCN使用因果卷积来更好地适应序列模型；以及使用扩张卷积和残差模块来记住历史信息。 ​ 该文章发表在IEEE2020期刊上，是借鉴的LSTM-AE的第一篇文章，只是将LSTM替换成了TCN，同样地，也是通过重构误差来检测异常。该文章在大部分数据集上的效果要稍稍优于LSTM-AE，但时间效率稍稍低于LSTM-AE。总体来说，可以参考一下该文TCN网络结构。 网络结构 ​","link":"/2021/07/12/article-read/"},{"title":"使用kettle遇到的一些问题","text":"kettle kettle是一款开源的数据etl工具，用于做数据抽取和整合。其功能是很强大的。若要连接某个数据库，要先在kettle的lib目录下放入对应的jar包。 简单的数据表聚合输出 右键目录树，软件会卡死 原因是kettel和当前的jdk版本有冲突，同时，右上角无connect，无法连接资源库也是因为这个原因。我用的kettel8.2对应jdk9.0.4异常，更换为1.8.0是正常的。 方法：下载jdk1.8.0，更改系统的环境变量JAVA_HOME和PATH，重启电脑并重启kettle。 中文输出乱码 kettle的字符集默认是GBK，在进行数据库操作时，修改为utf8 右键数据库连接，编辑 在数据库连接中选择高级，下方输入set name utf8;","link":"/2021/10/29/kettle-problems/"}],"tags":[{"name":"laravel","slug":"laravel","link":"/tags/laravel/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"apache","slug":"apache","link":"/tags/apache/"},{"name":"虚拟站点","slug":"虚拟站点","link":"/tags/%E8%99%9A%E6%8B%9F%E7%AB%99%E7%82%B9/"},{"name":"判断数据库是否有特定值","slug":"判断数据库是否有特定值","link":"/tags/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%90%A6%E6%9C%89%E7%89%B9%E5%AE%9A%E5%80%BC/"},{"name":"CI","slug":"CI","link":"/tags/CI/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"array_shift()","slug":"array-shift","link":"/tags/array-shift/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"cmder","slug":"cmder","link":"/tags/cmder/"},{"name":"命令框","slug":"命令框","link":"/tags/%E5%91%BD%E4%BB%A4%E6%A1%86/"},{"name":"wordpress","slug":"wordpress","link":"/tags/wordpress/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"centos，服务器","slug":"centos，服务器","link":"/tags/centos%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"mount","slug":"mount","link":"/tags/mount/"},{"name":"恢复数据","slug":"恢复数据","link":"/tags/%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"name":"故障","slug":"故障","link":"/tags/%E6%95%85%E9%9A%9C/"},{"name":"无法启动","slug":"无法启动","link":"/tags/%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"mysqldump","slug":"mysqldump","link":"/tags/mysqldump/"},{"name":"数据导出","slug":"数据导出","link":"/tags/%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA/"},{"name":"数据库迁移","slug":"数据库迁移","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB/"},{"name":"rem","slug":"rem","link":"/tags/rem/"},{"name":"移动端","slug":"移动端","link":"/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"时序","slug":"时序","link":"/tags/%E6%97%B6%E5%BA%8F/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"七牛云","slug":"七牛云","link":"/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"异常检测","slug":"异常检测","link":"/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"},{"name":"kettle","slug":"kettle","link":"/tags/kettle/"}],"categories":[{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"uncategorized","slug":"uncategorized","link":"/categories/uncategorized/"},{"name":"服务器","slug":"服务器","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"wordpress","slug":"wordpress","link":"/categories/wordpress/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Mysql","slug":"Mysql","link":"/categories/Mysql/"},{"name":"时序","slug":"时序","link":"/categories/%E6%97%B6%E5%BA%8F/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"时间序列","slug":"时间序列","link":"/categories/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"}]}